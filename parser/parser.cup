import java_cup.runtime.*;


parser code {:
  private String symToName(int id) {
    try { for (java.lang.reflect.Field f : parser.sym.class.getFields()) if (f.getInt(null)==id) return f.getName(); }
    catch (Exception ignore) {}
    return String.valueOf(id);
  }

  private void addSyn(int line, int col, String msg, int tokenId, String ctx){
    parser.SyntaxErrorCollector.add(line, col, msg, symToName(tokenId), ctx);
  }

  @Override
  public void report_error(String message, Object info) {
    java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
    addSyn(s.left+1, s.right+1, message, s.sym, "report_error");
  }

  @Override
  public void syntax_error(java_cup.runtime.Symbol cur_token) {
    addSyn(cur_token.left+1, cur_token.right+1, "Token inesperado", cur_token.sym, "syntax_error");
  }

  @Override
  public void report_fatal_error(String message, Object info) {
    java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
    addSyn(s.left+1, s.right+1, "Fatal: "+message, s.sym, "fatal");
    // NO lanzamos excepción aquí; dejamos que CUP intente recuperar.
  }

  @Override
  public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) throws java.lang.Exception {
    addSyn(cur_token.left+1, cur_token.right+1, "No se pudo recuperar", cur_token.sym, "abort");
  }
:};


/* TERMINALES */
terminal PROGRAM, VAR, FUNCTION, PROCEDURE, BEGIN, END, RETURN;
terminal IF, THEN, ELSE, WHILE, DO, FOR, TO, NOT, AND, OR;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal MOD_KW, DIV_KW;
terminal CARET;
terminal EQ, NE, LT, GT, LE, GE, ASSIGN;
terminal INT, REAL, CHAR, STRING;
terminal LPAREN, RPAREN, LBRACK, RBRACK, COMMA, SEMI, COLON, DOT;
terminal INCR, DECR;
terminal READ, WRITE;
terminal String IDENT;
terminal String INT_LIT, REAL_LIT, CHAR_LIT, STRING_LIT;

/* NO TERMINALES*/
non terminal program, globals_opt, decl_list, decl, type;
non terminal funcs_opt, func_or_proc, function, procedure;
non terminal main_block, stmt_list, stmt;
non terminal assign, call_stmt, expr, bool_expr;
non terminal param_list_opt, param_list, param;
non terminal while_stmt, for_stmt;
non terminal ident_list, arg_list_opt, arg_list;
non terminal if_stmt;
non terminal read_stmt, write_stmt;
non terminal block;
non terminal decl_section;
non terminal local_decl_list;
non terminal ret_stmt;

/* PRECEDENCIAS */
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left EQ, NE;
precedence left LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left LBRACK, RBRACK;
precedence left CARET;
precedence left TIMES, DIVIDE, MOD_KW, DIV_KW;


/* ==============PROGRAMA============== */
program ::= PROGRAM IDENT globals_opt funcs_opt main_block DOT;

/* VARIABLES */
globals_opt ::= 
                | VAR decl_list
;

decl_list ::= decl
            | decl_list decl
;

decl ::= ident_list COLON type SEMI
      | ident_list COLON error SEMI
      {: addSyn(((Symbol)$3).left+1, ((Symbol)$3).right+1,
                  "Tipo invalido en declaracion; recuperado en ';'",
                      ((Symbol)$3).sym, "decl"); :}
;

ident_list ::= IDENT 
              | ident_list COMMA IDENT
;

type ::= INT 
        | REAL 
        | CHAR 
        | STRING 
;

/* FUNCIONES */
funcs_opt ::= 
              | funcs_opt func_or_proc
;

func_or_proc ::= function 
                | procedure 
;

function ::= FUNCTION IDENT LPAREN param_list_opt RPAREN COLON type
             BEGIN block END SEMI;

procedure ::= PROCEDURE IDENT LPAREN param_list_opt RPAREN SEMI
              BEGIN block END SEMI;
              


/* MAIN */
main_block ::= BEGIN block END;

/* ================== BLOQUE ==================
   bloque = [declaraciones locales] + sentencias
   así CUP ya no confunde si el IDENT que sigue
   es otra decl o una sentencia.
*/

block ::= decl_section stmt_list
        | decl_section error   /* consume hasta END de quien invoca */
      {: addSyn(((Symbol)$2).left+1, ((Symbol)$2).right+1,
                  "Bloque invalido; recuperado en END", ((Symbol)$2).sym, "block"); :}
;

/* puede no haber VAR ... */
decl_section ::=
             | VAR local_decl_list
             | VAR error SEMI
             {: addSyn(((Symbol)$2).left+1, ((Symbol)$2).right+1,
                 "Declaracion local invalida; recuperado en ';'",
                 ((Symbol)$2).sym, "decl-section"); :}
;


/* Sentencias */
stmt_list ::= stmt
            | stmt_list stmt
            | stmt_list error SEMI
              {:
                Symbol e = (Symbol)$2;
                report_error("Sentencia invalida; recuperado en ';'", e);
              :}
            ;

stmt ::= assign SEMI
       | call_stmt SEMI
       | read_stmt SEMI
       | write_stmt SEMI
       | if_stmt
       | while_stmt
       | for_stmt
       | error SEMI
         {:
           Symbol e = (Symbol)$1;
           report_error("Sentencia invalida; recuperado", e);
         :}
       ;
       /* | ret_stmt */

assign ::= IDENT ASSIGN expr
         | IDENT ASSIGN bool_expr
         ;

call_stmt ::= IDENT LPAREN arg_list_opt RPAREN;

read_stmt ::= READ LPAREN RPAREN
            | READ LPAREN expr RPAREN
            ;

write_stmt ::= WRITE LPAREN arg_list RPAREN;

/* Argumentos */
arg_list_opt ::= 
                | arg_list
;

arg_list ::= expr
           | arg_list COMMA expr
;

/* EXPRESIONES */
expr ::= expr LBRACK expr RBRACK
       | expr CARET expr
       | expr PLUS expr
       | expr MINUS expr
       | expr TIMES expr
       | expr DIVIDE expr
       | expr MOD_KW expr
       | expr DIV_KW expr
       | MINUS expr
       | PLUS expr
       | IDENT
       | IDENT LPAREN arg_list_opt RPAREN
       | INT_LIT
       | REAL_LIT
       | CHAR_LIT
       | STRING_LIT
       | LPAREN expr RPAREN
       | INCR IDENT
       | IDENT INCR
       | DECR IDENT
       | IDENT DECR
;

/* BOOLEANS */
bool_expr ::= NOT bool_expr
            | bool_expr AND bool_expr
            | bool_expr OR bool_expr
            | expr EQ expr
            | expr NE expr
            | expr LT expr
            | expr LE expr
            | expr GT expr
            | expr GE expr
            | LPAREN bool_expr RPAREN
;

/* IF */
if_stmt ::=
    IF bool_expr THEN BEGIN stmt_list END SEMI
  | IF bool_expr THEN BEGIN stmt_list END ELSE BEGIN stmt_list END SEMI

  /* Error: falta THEN */
  | IF bool_expr error BEGIN stmt_list END SEMI
    {:
      Symbol err = (Symbol)$3;
      report_error("Falta THEN en IF; recuperado en BEGIN", err);
    :}

  /* Error: falta BEGIN después de THEN */
  | IF bool_expr THEN error stmt_list END SEMI
    {:
      Symbol err = (Symbol)$4;
      report_error("Falta BEGIN tras THEN; recuperado en END", err);
    :}

  /* Error: ELSE roto o mal escrito */
  | IF bool_expr THEN BEGIN stmt_list END error BEGIN stmt_list END SEMI
    {:
      Symbol err = (Symbol)$6;
      report_error("ELSE inválido; recuperado en siguiente BEGIN", err);
    :}

  /* Error: condición rota */
  | IF error THEN BEGIN stmt_list END SEMI
    {:
      Symbol err = (Symbol)$2;
      report_error("Condición inválida en IF; recuperado en THEN", err);
    :}

  /* Error: falta ';' final */
  | IF bool_expr THEN BEGIN stmt_list END error
    {:
      Symbol err = (Symbol)$6;
      report_error("Falta ';' al final del IF; recuperado", err);
    :}

  /* Error muy genérico para casos no contemplados */
  | IF error error
    {:
      Symbol err = (Symbol)$2;
      report_error("IF invalido; recuperado saltando hasta siguiente sentencia", err);
    :}
;


/* WHILE */
while_stmt ::=
      WHILE bool_expr DO BEGIN stmt_list END SEMI

    | WHILE error DO BEGIN stmt_list END SEMI
        {:
           java_cup.runtime.Symbol err = (java_cup.runtime.Symbol)$2;
           report_error("Condicion invalida tras WHILE; recuperado en DO", err);
        :}

    | WHILE bool_expr DO error END SEMI
        {:
           java_cup.runtime.Symbol err = (java_cup.runtime.Symbol)$4;
           report_error("Falta BEGIN tras DO; recuperado en END", err);
        :}
  ;

/* FOR */
/* FOR con recuperaciones */
for_stmt ::=
      FOR IDENT ASSIGN expr TO expr DO BEGIN stmt_list END SEMI

    | FOR IDENT ASSIGN error TO expr DO BEGIN stmt_list END SEMI
        {:
           java_cup.runtime.Symbol err = (java_cup.runtime.Symbol)$4;
           report_error("exp1 invalida en FOR; recuperado en TO", err);
        :}

    | FOR IDENT ASSIGN expr TO error DO BEGIN stmt_list END SEMI
        {:
           java_cup.runtime.Symbol err = (java_cup.runtime.Symbol)$6;
           report_error("exp2 invalida en FOR; recuperado en DO", err);
        :}

    | FOR IDENT ASSIGN expr TO expr DO error END SEMI
        {:
           java_cup.runtime.Symbol err = (java_cup.runtime.Symbol)$8;
           report_error("Falta BEGIN tras DO; recuperado en END", err);
        :}
  ;
/* PARAMS */
param_list_opt ::= 
                  | param_list
;

param_list ::= param
             | param_list SEMI param
;

param ::= ident_list COLON type;

ret_stmt ::= RETURN expr SEMI;