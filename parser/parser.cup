import java_cup.runtime.*;


parser code {:
  private String symToName(int id) {
    try { for (java.lang.reflect.Field f : parser.sym.class.getFields()) if (f.getInt(null)==id) return f.getName(); }
    catch (Exception ignore) {}
    return String.valueOf(id);
  }

  private void addSyn(int line, int col, String msg, int tokenId, String ctx){
    parser.SyntaxErrorCollector.add(line, col, msg, symToName(tokenId), ctx);
  }

  @Override
  public void report_error(String message, Object info) {
    java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
    addSyn(s.left+1, s.right+1, message, s.sym, "report_error");
  }

  @Override
  public void syntax_error(java_cup.runtime.Symbol cur_token) {
    addSyn(cur_token.left+1, cur_token.right+1, "Token inesperado", cur_token.sym, "syntax_error");
  }

  @Override
  public void report_fatal_error(String message, Object info) {
    java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
    addSyn(s.left+1, s.right+1, "Fatal: "+message, s.sym, "fatal");
    // NO lanzamos excepción aquí; dejamos que CUP intente recuperar.
  }

  @Override
  public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) throws java.lang.Exception {
    addSyn(cur_token.left+1, cur_token.right+1, "No se pudo recuperar", cur_token.sym, "abort");
  }
:};


/* TERMINALES */
terminal PROGRAM, VAR, FUNCTION, PROCEDURE, BEGIN, END, RETURN;
terminal IF, THEN, ELSE, WHILE, DO, FOR, TO, NOT, AND, OR;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal MOD_KW, DIV_KW;
terminal CARET;
terminal EQ, NE, LT, GT, LE, GE, ASSIGN;
terminal INT, REAL, CHAR, STRING;
terminal LPAREN, RPAREN, LBRACK, RBRACK, COMMA, SEMI, COLON, DOT;
terminal INCR, DECR;
terminal READ, WRITE;
terminal String IDENT;
terminal String INT_LIT, REAL_LIT, CHAR_LIT, STRING_LIT;

/* NO TERMINALES*/
non terminal program, globals_opt, decl_list, decl, type;
non terminal funcs_opt, func_or_proc, function, procedure;
non terminal main_block, stmt_list, stmt;
non terminal assign, call_stmt, expr, bool_expr;
non terminal param_list_opt, param_list, param;
non terminal while_stmt, for_stmt;
non terminal ident_list, arg_list_opt, arg_list;
non terminal if_stmt;
non terminal read_stmt, write_stmt;
non terminal block;
non terminal decl_section;
non terminal local_decl_list;
non terminal ret_stmt;

/* PRECEDENCIAS */
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left EQ, NE;
precedence left LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left LBRACK, RBRACK;
precedence left CARET;
precedence left TIMES, DIVIDE, MOD_KW, DIV_KW;


/* ==============PROGRAMA============== */
program ::= PROGRAM IDENT globals_opt funcs_opt main_block DOT;

/* VARIABLES */
globals_opt ::= 
                | VAR decl_list
;

decl_list ::= decl
            | decl_list decl
;

decl ::= ident_list COLON type SEMI;

ident_list ::= IDENT 
              | ident_list COMMA IDENT
;

type ::= INT 
        | REAL 
        | CHAR 
        | STRING 
;

/* FUNCIONES */
funcs_opt ::= 
              | funcs_opt func_or_proc
;

func_or_proc ::= function 
                | procedure 
;

function ::= FUNCTION IDENT LPAREN param_list_opt RPAREN COLON type
             BEGIN block END SEMI;

procedure ::= PROCEDURE IDENT LPAREN param_list_opt RPAREN SEMI
              BEGIN block END SEMI;
              


/* MAIN */
main_block ::= BEGIN block END;

/* ================== BLOQUE ==================
   bloque = [declaraciones locales] + sentencias
   así CUP ya no confunde si el IDENT que sigue
   es otra decl o una sentencia.
*/

block ::= decl_section stmt_list ;

/* puede no haber VAR ... */
decl_section ::=
             | VAR local_decl_list
             ;


/* Sentencias */
stmt_list ::= stmt
            | stmt_list stmt
;

stmt ::= assign SEMI
       | call_stmt SEMI
       | read_stmt SEMI
       | write_stmt SEMI
       | if_stmt
       | while_stmt
       | for_stmt
       /* | ret_stmt */
;

assign ::= IDENT ASSIGN expr
         | IDENT ASSIGN bool_expr
         ;

call_stmt ::= IDENT LPAREN arg_list_opt RPAREN;

read_stmt ::= READ LPAREN RPAREN
            | READ LPAREN expr RPAREN
            ;

write_stmt ::= WRITE LPAREN arg_list RPAREN;

/* Argumentos */
arg_list_opt ::= 
                | arg_list
;

arg_list ::= expr
           | arg_list COMMA expr
;

/* EXPRESIONES */
expr ::= expr LBRACK expr RBRACK
       | expr CARET expr
       | expr PLUS expr
       | expr MINUS expr
       | expr TIMES expr
       | expr DIVIDE expr
       | expr MOD_KW expr
       | expr DIV_KW expr
       | MINUS expr
       | PLUS expr
       | IDENT
       | IDENT LPAREN arg_list_opt RPAREN
       | INT_LIT
       | REAL_LIT
       | CHAR_LIT
       | STRING_LIT
       | LPAREN expr RPAREN
       | INCR IDENT
       | IDENT INCR
       | DECR IDENT
       | IDENT DECR
;

/* BOOLEANS */
bool_expr ::= NOT bool_expr
            | bool_expr AND bool_expr
            | bool_expr OR bool_expr
            | expr EQ expr
            | expr NE expr
            | expr LT expr
            | expr LE expr
            | expr GT expr
            | expr GE expr
            | LPAREN bool_expr RPAREN
;

/* IF */
if_stmt ::= IF bool_expr THEN BEGIN block END
          | IF bool_expr THEN BEGIN block END ELSE BEGIN block END
;

/* WHILE */
while_stmt ::= WHILE bool_expr DO BEGIN stmt_list END;

/* FOR */
for_stmt ::= FOR IDENT ASSIGN expr TO expr DO BEGIN stmt_list END;

/* PARAMS */
param_list_opt ::= 
                  | param_list
;

param_list ::= param
             | param_list SEMI param
;

param ::= ident_list COLON type;

ret_stmt ::= RETURN expr SEMI;